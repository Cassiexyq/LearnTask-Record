#### 设计模式

* 组合模式（composite pattern），又叫部分整体模式，依据**树形结构**组合对象，凡是有集合对象的，都可以用到组合模式

  * 举例：创建一个Employee类，该类作为组合模型类，里面定义有一个Employee对象的列表，可以演示一个组织中员工的层次结构；文件系统中存在文件夹和文件，这些文件可能存在不同的格式，浏览方式也不同，对文件夹的浏览就是对文件夹中文件的浏览，对客户而言都是浏览文件。
  * 使用场景：能从一个整体中独立出部分模块或功能的场景；只要是树形结构或只要体现了局部和整体的关系的时候（部分、整体场景，如树形菜单，文件、文件夹的管理）
  * 优点：高层模块调用简单，节点自由增加。
  * 缺点：使用组合模式，叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。
  * 我们将这颗树理解成一个大的容器，容器包含很多的成员对象，这些对象既可以是容器对象和叶子对象，但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象。作为客户而已，始终希望能够一致的对待容器的、对象和叶子对象。组合模式的**设计动机**：定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用过程无须区分，进行一致处理。
  * 角色：
    * Component：组合中的对象声明接口（抽象构件），实现所有类共有接口的默认行为。声明一个用于访问和管理Component子部件
    * leaf：叶子对象，叶子节点没有子节点
    * composite：容器对象（树枝构件），定义有枝节点行为，用来存储子部件，在component接口实现与子部件有关操作，如增加或删除

  * 安全模式和透明模式：安全模式在抽象组件中只定义一些默认的行为或属性，把树枝节点和树叶节点彻底分开；透明模式把组合使用的方法放到抽象类，不管叶子对象还是树枝对象都有相同的结构，通过判断确认是叶子还是树枝。
    * 安全模式与依赖倒置原则冲突，透明模式方便进行扩展。
    * 安全模式遍历树形结构需要强制类型转换；透明不用

* 工厂模式（Factory pattern）：

  * 简单工厂模式：只有一个工厂类。定义一个父类，有很多实现类，根据传入的参数实现各种对象的创建。专门定义一个类用来负责创建其他类的实例，被创建的实例通常都具有共同的父类，违背了**开放-封闭原则**，因为每次新添一个功能，都需要修改代码，添加分支条件
  * 工厂方法模式：不再提供统一的工厂类，而是针对对象来提供不同的工厂，有多个工厂。定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟到其子类
    * 抽象工厂角色，具体工厂角色，抽象产品角色，具体产品角色
  * 抽象工厂模式：提供一个创建一系列相关或者相互依赖对象的接口，而无需指定他们具体的类。
    * 假设我们要增加一个工厂，需要增加一个工厂类，每个产品需要增加一个工厂-产品类（这个产品的具体实现类）3个
    * 假设我们增加一个产品，需要增加一个产品父类，每个工厂父类及所有子类都需要增加一个此产品的创建，每个工厂需要增加一个工厂-产品类（新的产品接口，以及工厂的实现该产品的子类）假设2个工厂，3个已有的需要修改，3个需要新增
  * 抽象工厂的工厂和工厂方法中的工厂的**区别**：抽象工厂使生产一整套产品（至少要生产两个产品），这些产品必须是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。
  * 开闭原则：开闭原则要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，功能增强：
    * 增加产品族：对于增加新的产品族，抽象工厂模式很好支持，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改
    * 增加新的产品等级结构（每个工厂又有一个新的产品），需要修改所有工厂角色，包括抽象工厂类，在所有工厂类中都需要增加生产新产品的方法，违背开闭原则
  * 对**开闭原则**的支持：
    * 简单工厂支持差，新产品需要修改代码；
    * 工厂方法支持度高；
    * 抽象工厂支持度有**倾斜**，难以增加新的产品等级结构，方便增加新工厂和产品族

* 享元模式（Flyweight pool）：主要用于减少创建对象的数量，以减少内存占用和提高性能。**结构型**，采用一个共享来避免大量拥有相同对象的开销

  * 使用场景：JAVA中string就使用了享元模式，string对象是final类型，对象一旦创建就不可改变，在java中字符串常量都是存在常量池中，java确保一个字符串常常在常量池中只有一个拷贝
  * 内蕴状态和外蕴状态：
    * 一个内蕴状态存储在享元对象内部，不会随环境改变而不同，一个享元可以具有内蕴状态并共享。具体实现类中定义的变量就是内蕴状态，这个值在享元对象被创建时富裕，创建之后不会改变
    * 一个外蕴状态随环境改变、不可以共享，外蕴状态必须由客户端保存，并在对象被创建后传入内部。抽象类中的传入的参数是外蕴状态，外蕴状态不可以影响内蕴状态，是相互独立的。

  * 单纯享元模式和复合享元模式：

    * 单纯享元模式：所有享元对象都是单纯享元对象，可以直接共享

      * 角色：

      * 抽象享元角色：给出一个抽象接口，规定出所有具体享元角色需要实现的方法

      - 具体享元角色：实现抽象享元角色规定的接口，如果由内蕴状态，必须给内蕴状态提供存储空间
      - 享元工厂角色：作用在于提供一个用于存储享元对象的享元池，负责创建和管理享元角色，保证享元对象可以被系统适当共享。当客户端调用享元对象时，享元工厂角色会检查系统中是否已经由一个符合要求的享元对象，如果有就提供已有的，没有就创建。

    * 复合享元模式：本身不能共享，但可以分解成单纯享元对象，一个符合享元对象的所有单纯享元对象元素的外蕴状态都是与符合享元对象的外蕴状态相等，而一个复合享元对象的所有单纯享元对象的内蕴状态一般不相等。

  * 优点：可以减少内存对象的数量，节约资源，提高性能；外部状态相对独立，不会影响颞部装填，享元对象可以在不同环境中被共享。
  * 缺点：需要分离出内部状态和外部状态，逻辑复杂化；使对象可以共享，需将对象的部分状态外部话，读取外部状态时间变长

* 单例模式：最简单的设计模式之一，创建型模式

  * 应用实例：操作文件不可避免处理同一文件，需要通过唯一的实例来进行；打印机打印输出只能到一台打印机

  * 懒汉式，线程不安全，没有加锁
  * 懒汉式，线程安全，加锁影响效率，第一次调用才初始化避免内存浪费
  * 饿汉式：容易产生垃圾对象，没有加锁，类加载时就初始化，浪费内存

* 建造者模式：创建型模式
  * 举例：Java中的stringbuilder
  * 缺点：产品必须具有共同点，范围有限制；内部变化大，会有很多的建造类
  * 优点：建造者独立，易扩展；便于控制细节风险

* 桥接模式

* MVC：复合模式，观察者（V和C都是M的观察者，model的状态要及时更新通知V更新视图，或者通知C做相应逻辑处理），策略模式（C是V的策略，V包含的控制逻辑就是选择策略，也就是控制器），组合模式（V的自身实现了组合模式）

* 状态模式和策略模式的区别（策略模式是吧可替换的算法步骤封装成一个个算法，供运行时动态选择；状态模式把所有动作封装在状态对象，状态持有者将行为委托给当前状态对象）

* 命令模式下的宏命令

* 适配器模式：对象适配器和类适配器，一般java为对象适配器，类的涉及多重继承，适配器，首先实现转换成的类型接口，也就是客户所期望看到的接口，接着，需要取得适配的对象引用，然后实现接口中的所有方法。假设有两个对象为鸭子和火鸡，然后缺鸭子对象，用火鸡冒充，因为火鸡和鸭子对象不同，所有implements的鸭子，但其实是火鸡对象，在内部的实现里面是调用了火鸡的方法，但包装成鸭子的实现类。

* 设计原则：开闭原则，依赖倒置原则，最少知识，好莱坞，单一职责等

* ![](https://github.com/Cassiexyq/LearnTask-Record/blob/master/img/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.jpg)

  

